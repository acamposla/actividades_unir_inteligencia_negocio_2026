Bien, buenas tardes a todos. Bienvenidos a la sesión número 7 de Fundamentos Tecnológicos para el Tratamiento de Datos. En la sesión de hoy vamos a hacer tres cosas. Lo primero es corregir la actividad 1, que entregaste el lunes de la semana pasada. Por lo tanto, vamos a corregir el ejercicio y vamos a ver cuál es la solución efectivamente, pero también cuál no es la solución correcta. Vamos a ver qué claves no cumplen las restricciones que se piden. Una vez que terminemos con esa parte, procederemos a seguir con SQL. la semana pasada vimos la combinación de tablas y esta semana nos queda ya la última parte de esta primera toma de contacto con SQL que hace referencia a las funciones de agregación, que básicamente es lo mismo que hacemos con una pivot table en Excel y la subconsulta, que consiste en utilizar una consulta dentro de otra. Y finalmente os explicaré ya de cara a la semana que viene los ejercicios voluntarios ya de consultas, ¿Vale? De qué es lo que tenéis que hacer y dónde está. ¿De acuerdo? Por lo tanto, antes de empezar, si alguien tiene alguna duda, alguna pregunta que quiera hacerme, antes de que empecemos... ¿No? ¿Todo bien? Vale, perfecto. Pues nada, vamos entonces con la corrección de la actividad 1. Bueno, comentaros que somos 3, por eso que corregimos las actividades, ¿vale? Mi parte, yo ya la he terminado y según tengo entendido los otros dos compañeros, José y Juan Manuel, están terminando, ¿vale? Yo me imagino que de cara a la semana que viene pues ya estarán publicadas, ¿de acuerdo? y ya que estamos hablando de esto la actividad 2 ¿vale? que tiene la fecha de entrega el 5 de enero ¿vale? la vamos a posponer una semana ¿vale? es decir, la fecha de entrega será el día 12 de enero viene cierto que en la plataforma no va a cambiar la fecha, pero no pasa nada ¿vale? aunque no cambie la fecha, igualmente con que sea el día de antes del día 12 estaría bien ¿vale? porque efectivamente cuando yo corrijo las actividades me aparece a qué hora lo habéis subido y en qué día, ¿de acuerdo? Pero bueno, ya volveremos a la actividad 2 más adelante. Bien, por lo tanto, vamos con la actividad 1, que básicamente consistía en lo que hemos venido haciendo prácticamente desde el primer día de clase, ¿vale? Que es asignación de claves, ¿vale? Claves primarias y claves ajenas. Por lo tanto, aquí, al igual que en los ejercicios anteriores que hemos hecho, buscamos dos cosas, ¿vale? Primero, pues identificar la clave primaria y después asignarlas como claves ajenas cumpliendo las restricciones que nos piden en el ejercicio. Pero obviamente antes de ello yo os planteo una serie de tablas, que en este caso son 5, con una serie de atributos y vosotros tenéis que darle 4 valores, o mejor dicho, inventar 4 valores, después identificar las claves primarias y asignar esas claves primarias como ajenas para que se cumplan las restricciones. bien, por lo tanto, vamos a empezar con ello esto es una empresa de motocicletas, ¿vale? y está compuesta por 5 tablas servicio venta por venta, tipo de motocicleta que es tipología, no inventario tal y como hemos destacado muchas veces empleados, mecánicos y vendedores ¿vale? cada una de ellas tiene sus propios atributos ¿vale? por lo tanto, lo primero que tenemos que hacer es en Excel, simplemente darle 4 registros a cada una de estas tablas ¿de acuerdo? yo por ejemplo le he dado estas de aquí y una vez hecho esto empezamos con la asignación o mejor dicho, identificación de las claves primarias que en este caso es bastante sencillo, recordemos que la clave primaria es aquella que identifica de forma única cada uno de los registros, es decir, la vida real para nosotros las personas es por ejemplo el pasaporte ¿vale? por lo tanto en la tabla de servicios de venta efectivamente la clave primaria será factura, porque no puede ser ni fecha de pedido, ni tipo de reserva, ni ninguno de los otros, tipo de motocicleta es identificador de moto, en empleados es código de empleado, en mecánicos es código de mecánico y en vendedores es de vendedor. ¿De acuerdo? Bastante sencillo. También os recuerdo que normalmente, ahora que ya hemos empezado con SQL, cuando nos encontremos con las tablas, veremos que va a haber varias claves, algunas serán primarias, otras ajenas. ¿Vale? Pero recordemos que las claves primarias, como no se duplican, son únicas, pues ahí nos puede dar una idea de cuáles. ¿Vale? Bien, hecho esto, ahora tenemos que asignar estas claves primarias como claves ajenas, ¿vale? En otras tablas, para cumplir con las restricciones que se han planteado en la empresa. ¿De acuerdo? Por lo tanto, vamos con ello. Lo primero es un empleado puede ser mecánico o vendedor, nunca ambos. Es decir, aquí lo que se busca es establecer la relación entre empleados y mecánicos y empleados y vendedores. Porque obviamente mecánicos y vendedores no tienen una relación directa. Bien, entonces nosotros tenemos que un empleado puede ser o mecánico o vendedor. Supongamos que un empleado es un mecánico, ¿vale? No puede ser varios mecánicos, solamente uno. Y un mecánico a su vez va a ser un único empleado, no pueden ser dos. entonces en este caso la cardinalidad es teniendo en cuenta que tenemos las cardinalidades de uno a muchos, uno a uno o muchos a muchos en este caso es bastante sencillo, ¿de acuerdo? ¿por qué? porque es uno a uno, efectivamente entonces en este caso con los uno a uno no tenemos que es decir, tenemos dos posibilidades de asignar claves ajenas es decir, o podemos traernos aquí el código de empleado a mecánicos como clave ajena o podemos tener el código de mecánico como clave ajena en empleados. Cualquiera de las dos opciones es válida. Viene cierto que no hace falta poner ambas, solo una. Por ejemplo, en este caso vamos a optar por especificar únicamente el código de empleado en mecánicos. Ahora, en cuanto a vendedores, la tesitura es exactamente la misma. Es decir, un empleado va a ser un vendedor y un vendedor va a ser un empleado. seguimos con la cardinalidad 1 a 1 ¿de acuerdo? por lo tanto lo que hacemos aquí es lo mismo asignamos el código de empleado como clave ajena o si queremos podemos asignar y de vendedor como clave ajena en empleados ¿de acuerdo? en este caso como hemos optado por incluir código de empleados mecánicos pues vamos a hacer lo mismo con vendedores ¿de acuerdo? esta primera parte muy sencilla en esencia porque al ser relaciones uno a uno, pues son bastante obvias. Bien, seguimos. La segunda especifica que una factura solo puede contener una única moto. Es decir, por cada factura, una moto. Pero también en la tercera nos dice que un modelo de moto, sin embargo, puede estar presente en varias facturas. Es decir, puede ser vendido varias veces. ¿De acuerdo? Por lo tanto, tenemos que una factura va a tener una única moto, pero un tipo de moto puede estar presente en varias facturas. ¿De acuerdo? Entonces, en ese caso, ¿qué cardinalidad tenemos? ¿Cuál es la cardinalidad? 1 a muchos, es decir, 1 a n. Y que hemos dicho siempre, que la clave primaria del 1 se asigna como clave ajena en n. entonces aquí la clavagena cuál es tipo de moto o factura y efectivamente es tipo de moto porque porque un tipo por ejemplo estar aquí puede ser vendida en varias facturas es decir a varias personas alejandro factura es decir tú pondrías factura aquí Ah, vale Vale, casi un error, vale, vale, sin problema Efectivamente Incluimos identificador de moto En facturas, bien, por otro lado Tenemos el mismo tipo De moto puede ser vendido a varios clientes Esto es un poco para contextualizar ¿Por qué? Porque realmente yo no os he pedido Ninguna tabla de cliente en ningún momento Pero si la hubiese, que alguno de hecho Lo habéis hecho, se incluiría ¿De qué manera? Pues creando la tabla de clientes y también se incluiría aquí como clave ajena. Pero vuelvo a insistir, esto no es algo que se os pedía en el ejercicio. Bien, seguimos. No se especifica. Los diferentes modelos de motos pueden ser vendidos por diferentes vendedores. Es decir, un tipo de moto lo puede vender cualquier vendedor, ¿vale? Pero, por otro lado, ¿vale? Un vendedor, ¿qué va a pasar? pues puede vender varias motos no porque realmente un vendedor no va a vender una única y ya está y no sé de autodespide entonces aquí que es lo que tenemos un tipo de moto varios vendedores un vendedor varios tipos de motos entonces si nosotros queremos relacionar directamente tipo de moto y vendedores podemos hacerlo qué cardinalidad hay directamente entre estas dos tablas eso es muchos a muchos y que hemos dicho que muchos a muchos no es algo que no podemos permitir en una base de datos entonces para solucionar esto lo que se suele hacer es que utilizar una tabla intermedia que en este caso ¿cuál utilizaríamos? como bien dice María vamos a utilizar la tabla de ventas, es decir, aquí es donde yo podría relacionar tipo de moto con los vendedores ¿de acuerdo? entonces aquí básicamente lo que hago es especificar el ID de vendedor como clave ajena en venta en la tabla de ventas ¿de acuerdo? ¿de acuerdo? ¿sí? y ya por último ¿vale? nos dice que un mecánico se le asigna una o más motos para su revisión ¿vale? pero una moto solo tiene asignado un único mecánico pero en una misma venta vale porque si no existe en general sí que es verdad que una moto puede ser gestionado por cualquier mecánico en pregunta si puede ir aquí el código de empleado ahora lo vemos vale qué es lo que es decir las claves que no podemos especificar en un saber ahora lo explicamos vale no te preocupes bien por lo tanto si nosotros tenemos que un tipo de moto vale un tipo de moto tiene un único mecánico pero en una misma venta pero si fuese en la tabla general un tipo de moto puede estar asignado a varios mecánicos vale y es solo a uno en el caso de que sea una misma venta es decir aquí ya está dando un poco entender que los mecánicos en esencia cómo se comportan dentro de la base de datos de la misma manera que los vendedores ¿de acuerdo? es decir, un tipo de moto puede tener varios mecánicos y un mecánico puede tener varios tipos de motos y nos hace falta una tabla intermedia para ello ¿de acuerdo? que es la de ventas, entonces efectivamente incluimos también el código de mecánico en ventas, ¿vale? quedando realmente el ejercicio así, ¿vale? por lo tanto tenemos la opción de esto siempre va a ser igual y lo único que puede variar es que incluyamos código mecánico vendedor como ajena de empleados o bajamos el código de empleado a las otras dos ahora Edwin pregunta ¿podemos realmente establecer el código de empleado aquí? ¿qué pensáis? ¿sería una buena solución? ¿por qué? ¿Se puede o no se puede? ¿Qué pensáis? No se puede, profe. Efectivamente, no se puede. ¿Por qué? Porque un empleado puede ser mecánico o vendedor. Es decir, si yo incluyo aquí código de empleado, primero, ¿a qué estoy haciendo referencia? ¿Al vendedor o al mecánico? Y lo segundo, como dice Estefanía, imagínate que incluyo ambos. pero claro, yo no puedo incluir aquí dos datos ¿vale? es decir, que si nosotros quisiésemos poner código de empleado habría que ponerlo dos veces, pero es que aparte si hacemos eso acabaríamos con lo que ya tenemos aquí, entonces efectivamente no, el código de empleado no lo podemos incluir esta tabla únicamente tiene esta solución ahora, si incluimos a cualquiera de las otras no es válido, cualquiera de las otras claves ¿vale? ahora en cuanto a tipo de motocicleta yo puedo incluir aquí factura, no puedo ¿por qué? porque ya hemos dicho, esto es tipología, una moto puede estar presente en varias facturas, si lo incluimos aquí se duplicará, lo mismo con el código de empleado, no tiene sentido porque no hace referencia si es vendedor o mecánico pero tampoco podemos incluir ni mecánico ni vendedor ¿vale? porque un mecánico solo tiene una moto pero en el momento de la venta, es decir, aquí arriba, pero en términos generales un mecánico puede arreglar o tener asociada cualquier moto, ¿de acuerdo? Después, en empleados, obviamente no podemos poner factura, tampoco tenía sentido, es decir, un empleado solo va a tener una factura, para empezar, ¿qué empleado? Vendedor o mecánico no puede ser, tipología de moto tampoco, ¿vale? Y finalmente, tanto mecánicos o vendedores, tampoco podemos incluir ni factura ni tipo de moto, ¿por qué? Porque un mecánico va a estar asignada varias facturas porque va a tener varias motos y lo mismo ocurre con los vendedores de acuerdo dudas preguntas no claro bien, perfecto vale, pues entonces vamos a seguir con SQL, ¿de acuerdo? un breve repaso, la semana pasada si recordáis nosotros veíamos la combinación de tablas, que en esencia el ejercicio 1 es precisamente lo que nos preparaba para esto ¿por qué? porque ahí es donde teníamos el funcionamiento de las claves de las keys, ¿vale? y la semana pasada vimos que había 3 tipos de join que nosotros vayamos a utilizar. Como ya os he comentado, hay otros que todavía no vamos a tocar. Entonces, tenemos por una parte el inner join, que si recordemos es que combina, pero solo nos devuelve resultados siempre y cuando haya una correspondencia entre las dos tablas. ¿Qué quiere decir esto? Si hay alguna tabla, algún registro que no tiene una equivalencia en la otra tabla, no nos aparece. Inner join es que tiene que ser un matcheo perfecto. ¿Vale? Después tenemos left join, ¿vale? Que left, que es la izquierda, y quiere decir que le da prioridad a la tabla de la izquierda, que normalmente es la primera tabla, ¿vale? ¿Qué quiere decir esto? Que nos devuelve todos los registros de la primera tabla, y de la segunda, si hay una correspondencia, nos devuelve la fila, ¿vale? Y si no hay correspondencia, esa fila tomaría valor null. y después tenemos el right join que sería exactamente lo mismo solo que al revés, se le da prioridad a la tabla número 2 que sería la tabla de la cual nos devolvería todos los registros y si hay una equivalencia en la primera tabla nos devuelve la fila y si no la hay la fila tomaría valor nulo. Bien, pues en la sesión de hoy vamos a terminar con esta primera parte en la que vemos las cláusulas, en la cual nosotros vamos a ver las subconsultas, que básicamente es que nosotros utilizamos una consulta dentro de otra, básicamente utilizamos el resultado de una consulta para alimentar otra, y veremos las funciones de agregación. que en esencia no es más que las funciones de que nosotros normalmente utilizamos en las pivot table vale en las tablas dinámicas ok bien por lo tanto vamos con ello de acuerdo primero vamos a a ver las funciones de agregación. Y para ello vamos a reutilizar lo que ya vimos la semana pasada, que es la tabla de matrícula, que tenía algunos campos que nos pueden ser interesantes de calcular. Es decir, recordad que en la tabla de matrícula nosotros tenemos lo siguiente. tenemos aquí el código de alumno, asignatura, profesor ID y por ejemplo tenemos la calificación ¿de acuerdo? por lo tanto nosotros de matrícula nos vamos a quedar solo con algunos campos como es el trimestre, el curso, la convocatoria y la calificación, ¿vale? Y ahora lo que vamos a hacer es combinar con la tabla de alumnos para obtener el nombre del alumno, ¿de acuerdo? Bueno, vamos a incluir también idea asignatura, ¿vale? Para, aunque no tengamos el nombre, pues tener una idea de qué asignatura es. Y finalmente ahora querríamos el nombre del alumno y para ello pues vamos a repasar el JOIN, ¿vale? Recordemos que con el join lo primero tenemos la tabla número 1 a la cual le asignamos un alias, el que nosotros queramos, como por ejemplo MA, ¿vale? De matrícula. Después pasamos a utilizar el join, en este caso vamos a utilizar el normal, inner join, ¿vale? Segunda tabla, su alias, on y aquí especificamos las claves, ¿vale? Que en este caso es el número de alumno que sea igual al número de alumno, ¿vale? Ahora, cuidado, como ya hemos establecido los alias, también vamos a incluirlos aquí en el cell. Vale, y finalmente, como decíamos, de la tabla de alumnos, el nombre de alumno. Bien, supongamos que nosotros tenemos este resultado, ¿no? Son 54 filas y si nosotros trabajásemos en Excel, pues sería algo así, ¿no? De hecho voy a copiar el resultado, voy a abrir un Excel nuevo y ahora supongamos que a nosotros nos pasa en este resultado, un segundito porque voy a cambiar el punto por la coma para que me lo convierta en numérico, ahora. Tenemos este resultado y vamos a hacer una tabla dinámica. Bueno, todo el mundo, me imagino que aquí, ha utilizado las pivot tables o las tablas dinámicas, ¿verdad? Sí, ¿no? Efectivamente. Entonces, ahora imaginad que con calificación, nuestro campo numérico, nosotros queremos, por una parte, hacer un recuento, ¿vale? Tenemos varias opciones. Hacemos un recuento, podemos hacer un somatorio, podemos hacer un promedio, podemos hacer también el valor máximo y el valor mínimo. ¿de acuerdo? ahora bien, ¿cómo consigo yo hacer estos cálculos en SQL? pues de la siguiente manera, ¿vale? lo que voy a hacer es voy a copiar esta consulta, lo voy a pegar y volver a poner aquí voy a copiar los datos ¿vale? lo tengo aquí y ahora si yo quiero un recuento ¿todo el mundo tiene clara la diferencia entre recuento y suma? recuento es que me cuenta los registros suma es que de cada registro me suma lo que hay dentro ¿vale? por lo tanto para el recuento nosotros tenemos la función count y aquí realmente no hace falta que especifiquemos ningún campo en particular porque con que especificamos cualquiera o todos lo que va a hacer es básicamente contar las filas ¿vale? ahora tenemos recuento ahora, si es lo que queremos en una suma igual que hacíamos en Excel que es el sum pues lo aplicamos ¿qué ocurre? aquí ya no puedo aplicar el asterisco ¿vale? aquí tengo que especificar exactamente qué campo es el que quiero sumar que en este caso es el de calificación. Después tenemos la media, que sería Average, que también tiene que ser de calificación. Tenemos el Max, que sería el valor máximo de todos. y el mi, que sería el min. ¿Vale? Y ahora, si yo ejecuto esto, pues efectivamente, como veis, me devuelve exactamente el mismo resultado. ¿Lo veis? Es decir, con SQL yo también puedo hacer tablas dinámicas si yo no me quiero descargar todo y lo quiero hacer directamente puedo perdón, exacto a eso vamos ahora, pero esto normalmente no es lo que queremos nosotros queremos estos cálculos en función de otro atributo o otra variable, ¿verdad? por ejemplo, antes de ir a alumnos vamos a ir a convocatorios y me haría el recuento, la suma, el promedio el máximo o el mínimo de cada convocatoria, que en este caso son dos, junio y septiembre. Por lo tanto, tengo para junio unos cálculos y para septiembre otros. ¿De acuerdo? Entonces, ¿aquí cómo lo puedo hacer? Pues de la siguiente manera. Nos hacen falta dos cosas. Lo primero es especificar la función GROUP BY al final. GROUP BY va después del WHERE. Es verdad que nosotros en este caso no aplicamos ningún WHERE, pero si lo hubiese pues el group by iría detrás y aquí como por ejemplo dice alejandro especificar y amos en base a qué atributo que queremos hacer el sumatorio la media etcétera vale por lo tanto aquí voy a especificar convocatoria vale si yo ejecuto esto fijaros me da los mismos resultados Pero, ¿qué falta aquí, que tengo aquí, pero no lo tengo aquí? ¿Qué es? Que de hecho me ayuda a interpretar. La etiqueta. Es decir, yo no sé si esto es de junio o de septiembre. ¿Verdad? Bien. Entonces, fijaros. Si yo el recuento es esto, el sumatorio es esto, la media es esto y demás. convocatoria, si yo lo quiero añadir aquí donde lo pongo aparte el groupby eso es, perfecto como dice el compañero Alejandro, efectivamente lo incluyo aquí ¿vale? y ahora sí, si ejecuto me lo devuelve, entonces cada vez que nosotros trabajemos con funciones de agregación hay dos partes importantes el group by y la etiqueta por la que agrupamos pero también tenemos que incluir esa etiqueta aquí, ¿vale? Ahora, como decía Alejandro, oye, ¿y qué pasa con nombre de alumno? Y se lo quiero así, es decir, por cada alumno y después cada una de las convocatorias ¿Qué es lo que haría? Sabiendo que nosotros hemos incluido ya aquí un campo, ¿qué hago? pues incluyo otro, como por ejemplo el nombre de alumno ¿vale? y ejecuto porque fijaros, me da error ¿por qué crees que me da error? está en el group by eso es, ojo lo que os he dicho antes, todo lo que incluyamos en el select, también tiene que estar en el group by, y ojo y viceversa, ¿vale? por lo tanto, efectivamente incluyo aquí nombre de alumno y ahora sí para Beatriz, junio y septiembre Francisco, junio y septiembre etcétera, etcétera ¿de acuerdo? ¿de acuerdo? ¿a qué te refieres con short by, Alejandro? ordenar el qué ¿qué es lo que llega a ordenar? ¿en base a qué? ah, ordenar en función de la media ¿vale? Si recordáis, creo que lo hemos visto, ¿no? ¿Cuál era la función con la que podíamos ordenar el resultado? ¿Quién se acuerda? Nope. Order by. Eso es, muy bien. Order by quería el final del todo y, por ejemplo, ¿qué queremos? ¿Ordenarlo en función de la media? Pues yo vengo aquí y especifico order by calificación. Por defecto, ¿qué hace? Lo hace de forma ascendente. ¿Os acordáis que poníamos ASC? Que si lo ponemos o no lo ponemos es lo mismo, pero si queremos que sea de forma descendente, DSC. ¿Ok? Si yo lo quiero ordenar también por convocatoria, como dice Mónica, puedo hacer lo siguiente. convocatoria de manera ascendente para que junio vaya antes que septiembre y después la media que sea de mayor a menor y listo ok si dudas ahora os pregunto ¿Sí? ¿Alguien ha hecho algo? Todo bien, ¿no? Vale. Entonces, imaginaros. Voy un momentito, ¿vale? A copiar esto, lo voy a simplificar un poco, porque quiero que veamos otra cuestión más. ¿Vale? Supongamos que voy a quitar convocatoria, voy a dejar solo alumno, ¿vale? Tanto lo quito de aquí también, y esto, bueno, lo quito, para que sea más sencillo de ver el código. bien nosotros tenemos aquí por cada alumno, recuento, sumatorio media, máximo y mínimo ¿de acuerdo? imaginemos que nos dicen, nosotros tenemos aunque tenemos 5, porque imaginad que tenemos 20 alumnos y nos dicen, vale, de este listado yo solo quiero aquellos que han sacado más de un 6 y medio de media es decir, que la media sea superior al 6 y medio ¿qué pensáis? ¿Cómo lo haríamos? Nosotros normalmente con qué filtramos a nivel de fila. Con el WHERE, ¿no? Pues vamos a probar. Y le digo, vale, WHERE, la media que sea mayor o igual que 6,5. ¿No? Ejecuto y ¡pum! No me deja. ¿Alguien sabría decirme el por qué? ¿O Alejandro ha hecho spoiler? ¿Debería ir después del group by? No. El web va antes del group by. Pero Alejandro no ha hecho spoiler. Fijaros. Nosotros el web lo utilizamos para filtrar en un campo que existe, una tabla. ¿Verdad? Es decir, nosotros podemos filtrar que la convocatoria sea junio, que el curso sea primero. ¿Pero qué ocurre? ¿Estos campos, estos atributos, existen almacenados en alguna tabla? No, ¿verdad? No existen. Son campos que ahora mismo nosotros estamos calculando mediante funciones de agregación. Es decir, que no están almacenados ni en matrícula ni en alumno. En matrícula está almacenado calificación, pero yo lo estoy calculando la media. ¿vale? es decir, esto es un cálculo entonces, al no estar almacenado una tabla en forma de registro, yo no puedo aplicarle el WHERE, y para ello después del GROUP BY, en este caso sí utilizo HAVING, ¿vale? HAVING lo utilizamos para filtrar las funciones de agregación, y ahora sí pondría que sea superior a 6,5, ¿vale? y si yo ahora ejecuto esto ahora, como veis, sí que lo filtra efectivamente que resumen, como dice Alejandro si nosotros vamos a filtrar por algo que estamos calculando en la consulta ya sea con un count, con un average, etc utilizamos having, pero por otro lado si nosotros tenemos algo ya almacenado en una tabla, como por ejemplo, convocatoria, sí que voy al web. Por ejemplo, si yo quiero la convocatoria de junio, utilizo mi web para filtrar a nivel de fila y después, una vez que se calcule la media, que digo que ese cálculo sea superior a 6,5. ¿De acuerdo? Y como veis, efectivamente, el resultado varía. ¿Sí? Claro, es decir, el WHERE es para cuando nuestra tabla que no le hemos aplicado ninguna función de agregación y está almacenada así, yo por cada fila quiero filtrar, pero si yo quiero filtrar un cálculo ¿Vale? Un sumatorio un máximo, un mínimo, una media y en el momento de estar ejecutando este cálculo, que es lo que estoy haciendo aquí y lo quiero filtrar lo hago con el habit María, algo así se podría hacer, pero eso lo vamos a descubrir más adelante porque vamos a poder utilizar subconsultas para hacer eso si queréis al final de la clase María recuérdamelo este comentario que acabo de ponerle y lo vemos las tablas de join no se pueden guardar ¿a qué te refieres las tablas de join Alejandro? es decir, ¿esto, el resultado de esto si se guarda en algún lado? es decir, ¿se guarda para que tú después la puedas volver a consultar? ¿o cómo? abre el micro si quieres, va a ser más fácil lo has abierto pero no te escucho voy a ver si soy yo no, yo sí tengo el volumen escucháis al compañero o solo soy yo? porque ha abierto el micro pero no se escucha no, no se escucha Alejandra, no se te escucha bueno, intenta arreglar si quiere lo del micro me pregunta, es que no entiendo, las tablas de join esta tabla esto esto no es una tabla, es una consulta es una query y tú lo que tú dices es si esto por ejemplo esto sale aquí abajo se guarda en algún lado esto no se guarda es el resultado de una consulta tú puedes ejecutarla las veces que tú quieras para obtener este resultado pero esto no se guarda en ningún lado vale ok no se puede guardar o sea no hay una que lo guarde y lo cree como una tabla nueva hay una manera de guardar, ¿vale? Pero lo veremos más adelante. Pero no consiste en guardar los datos como tal, porque imagínate que al día siguiente va a haber datos nuevos en las tablas. Aquí no. En la vida real hay datos nuevos. Entonces, claro, si tú guardas con lo que pasó ayer, no te interesa, porque tú lo quieres ver todo. Entonces, lo que nosotros más adelante vamos a hacer es que si hacemos una consulta, como por ejemplo esta, podamos guardarla en la base de datos como una especie de tabla virtual y es lo que se llama vista o view, ¿vale? La view nos permite guardar dentro el código ¿vale? Y después nosotros esa view la podemos utilizar como si fuese una tabla, ¿vale? Lo que oponíamos que me dé una tabla. Sí, ahora sí, Alejandro, ahora sí. Sí, me refiero a que si o sea, si lo de la view que estabas diciendo ahora se guarda, si se hace algo, ¿no? Pero me refiero a si si este tipo de tablas que generamos o de queries de resultado de resultado si se suelen guardar o sea se suelen usar directamente como una tabla de negocio o si por el contrario lo normal es como no las tengo siempre separadas y entonces siempre hago joins no sé si me explico no no no creo que más o menos más o menos creo que entienden ya para ponerse para llegar a esto hemos tenido que hacer para llegar a esto nos tiene que hacer esto vale entonces a mejorar en que necesita esto entonces entiendo que se guarda como una vista o luego se hace en power vía y guarda o no es como me se guarda el merecido a eso creo que tienen que entender tú recibe que si se guardan los propios datos esto que hemos ejecutado si se guardan la base de datos y tú lo pueda recuperar. Finalmente, no. Es decir, esto que nosotros aquí obtenemos, si yo ahora mismo cierro SQL y vuelvo a abrir, no hay rastro de ello. Es decir, no hay quien volver a ejecutar el código. Imagínate, por poner un ejemplo que sea un poco más de empresa. Imaginad que tenemos los datos precisamente de matrícula y de alumno y imagínate, a lo mejor de hoy a dentro de una semana en la tabla de matrícula de alumno van a haber más registros, van a haber cambios, que sería lo más normal. entonces claro, si nosotros guardamos esto tal cual en la base de datos que podríamos hacerlo sería con un día específico ¿vale? es decir que estos datos realmente para la semana que viene una vez que ha ocurrido la semana seguramente ya no valga, porque no sea la realidad ¿verdad? entonces lo que se suele hacer es que se guarda como antes comentaba, el código el código se guarda en una vista ¿vale? y por ejemplo, la semana que viene, tú vuelves a ejecutar la vista y por detrás se vuelve a ejecutar el código y te devuelve un resultado diferente. Ahora, si tú lo que te refieres, imagínate, yo quiero analizar cómo estaba la situación esta semana frente a la semana pasada, ¿vale? Para comparar, hacerle como una especie de fotos, lo que suele dominar como snapshot. Si eso nosotros no lo podemos hacer, pero, por ejemplo, en el trono empresarial siempre se puede hablar con ingeniería de datos para decir, vale, yo de esta consulta, aunque en este caso se llama bien de las tablas, y le decíamos, vale, hazme un snapshot de cómo estaba la situación, tal día se creía un campo con el día de la foto como suelo decir, con todos los registros y la semana siguiente pues se haría otro y podías comparar entre uno y otro pero lo que es guardar el propio resultado realmente tampoco tendría sentido, ¿por qué? porque tú puedes volver a ejecutar la consulta y volver a obtenerlo, ¿vale? si tú guardas esto ocupas espacio, pero si tú guardas la query dentro de una vista, el espacio que ocupas es mínimo. Entonces, lo más normal es que en vez de utilizar los datos que ya están almacenados como tal, por eso se utiliza SQL, porque se hace diferentes tipos de queries, o sea, con combinaciones, para sacar algo específico. Y si lo quieres reutilizar, tú lo que quieres reutilizar es el código, no los datos, porque los datos van a ir variando con el tiempo. Es decir, no se van a quedar estáticos. ¿Vale? Gracias. Sin problema. No sé si te he contestado lo que tú preguntabas, Alejandro, si no... Sí, sí me has contestado, pero luego me surgen más preguntas, pero más adelante que seguro que hay oportunidad. Ah, vale, perfecto. De todas maneras, no os preocupéis, porque el tema de vistas, lo que os he comentado, que también ha preguntado la compañera, que es guardar el código, el script que hemos hecho dentro de la base de datos, es algo, lo más normal del mundo. de hecho, imaginad, si hacéis una entrevista por un puesto de analista de datos en SQL es más probable que os pregunten por el concepto de vista, ¿vale? yo de todas las empresas que he trabajado en todas hemos trabajado en base a vista ¿vale? pero bueno, no os preocupéis que eso más adelante lo veremos ¿ok? bien si, lo que acabo de hacer, Paulina fíjate, por ejemplo, aquí yo vengo aquí y tengo la opción de Save result as, lo puedes guardar como en Excel o simplemente copiar que vienes a un Excel y lo pegas eso sí, es decir, lo que es extraer la información, perfecto, igual que antes lo comentaba Alejandro también, oye, ¿y puedo cargarlo en Power BI? efectivamente ¿vale? exacto bien ¿claras las funciones de agregación? obviamente no os preocupéis acabamos de ver, ¿vale? es decir, va a haber ejercicios en los que lo practiquemos y nos salgo, quedemos una vez y ya está. ¿Ok? Sí, ejercicio no os preocupéis, que es lo que ha dicho también Ana. Ahora cuando terminemos, yo ya os he subido un ejercicio de cada semana que viene, que son 8 consultas con otras tablas. Ahora al final de la clase hablaremos de ello. Bien, el segundo punto que vamos a ver hoy son las subconsultas. Las subconsultas básicamente es utilizar dos consultas a la vez, de la manera que tú utilizas una consulta dentro de otra, o mejor dicho, el resultado de una consulta dentro de otra. Por lo tanto, hay dos maneras de utilizar subconsultas, como filtro y como optimización de join. Ahora veremos a qué hace referencia cada uno. Filtro. Aquí, para poneros un ejemplo que más o menos veamos. Imaginad que nosotros tenemos dos tablas diferentes. Tenemos la tabla de asignaturas, porque se ve un poco así, es que se me ha quedado el teclado sin pilas y no tengo en casa. Tenemos la tabla de asignatura. ¿Vale? Esta tabla que ya hemos visto en varias ocasiones, ¿verdad? Bien, y por otro lado tenemos la tabla de profesor, ¿cierto? Bien, tengo ahora mismo estas dos tablas por separado. Y yo digo, vale, yo lo que necesito es de profesor, esta consulta de aquí, filtrar esta tabla solo para los profesores Jesús y Javier. Y esto es un poco de repaso. Si yo quiero filtrar esta consulta para que me devuelva información solo de Javier y de Jesús, ¿cómo lo hago? Eso es, muy bien, where, después del where, ¿qué sigue? El atributo, ¿no? Y ahora, fijaros, ¿qué utilizo aquí? ¿Tengo un dato por el que voy a filtrar o varios? varios, ¿verdad? porque quiero filtrar que sean Javier y Jesús entonces son dos, no puedo utilizar igual porque es un conjunto de datos y como dice el compañero, tampoco Paulina, como dice Alejandro si queremos filtrar por un conjunto de datos tenemos que utilizar IN y entre paréntesis pues especificar por lo que vamos a filtrar que en este caso es Javier y Jesús. Si yo ejecuto esto ahora, pues efectivamente filtro estos dos. Y ahora volviendo a la tabla de asignaturas que están por separadas, viendo esto, ¿cómo se llaman, o mejor dicho, cuáles son las ideas de las asignaturas de estos dos profesores? Porque mirándolos con los datos lo podemos mirar, ¿verdad? el 97, como dice Francisco, ¿por qué? porque es el profesor 245, que es quién, Javier, ¿verdad? y 99, que es el profesor 478, que es Jesús entonces, técnicamente, si yo quisiese filtrar por las asignaturas de ellos dos sin combinar, ¿qué haría? yo diría, profesor ID, ¿no? en el web, profesor ID igual utilizo el IN y especifico aquí el que 2, 4, 5 y 4, 7, 8 ¿verdad? que sería el equivalente de filtrar por Javier y Jesús ¿correcto? ¿sí verdad? ¿todo el mundo me sigue? bien 2, 4, 5 y 4, 7, 8 es lo mismo que esta consulta? ¿Sí o no? ¿Esta consulta devuelve 245 y 478? Sí, ¿no? Entonces, yo podría hacer que sustituir, en vez de establecer los códigos como tal, yo puedo utilizar la consulta para que me devuelva 245 y 478 ¿qué pasará por el IN del profesor ID y qué? y me devolvería el resultado es decir, esto es una subconsulta, ¿por qué? porque tengo una consulta que alimenta ¿qué? otra ¿de acuerdo? ¿y qué gano yo con esto? Que no necesito hacer un join. Ahora mismo los joins que hacemos son con tablas pequeñas, no se nota, pero imaginad que nosotros queremos hacer joins con tablas del mundo real que pueden llegar a ser bastante pesadas. Entonces nosotros podemos utilizar las subconsultas como una forma de filtrar sin tener que recurrir al join. pero tiene una desventaja ¿por qué? porque en este select yo solo puedo devolver campos de asignatura no puedo obtener ninguno del profesor es decir, utilizamos las subconsultas como filtro siempre y cuando nosotros todos los atributos que necesitemos estén en la tabla del from o lo que vayamos a filtrar en el where venga de la tabla del from Es decir, no podemos utilizar ningún campo de la tabla de profesor. ¿De acuerdo? En el select de la subconsulta puedes añadir campos. Pues imagínate, si yo aquí pongo, por ejemplo, nombre, ¿vale? Y ejecuto, ¿qué va a pasar? Si yo hago esto, va a fallar. ¿Por qué? Porque yo le estoy dando a entender aquí que le voy a pasar el qué, el profesor ID. Entonces, si yo aquí le incluyo algo que no sea el profesor ID, primero, no me va a filtrar bien o en este caso ni siquiera se va a poder ejecutar. Porque le estoy diciendo que el profesor ID y le tengo que dar aquí una serie de valores, pero en vez de darle valores le estoy dando una matriz. ¿vale? pero muy bien dicho lo de Alejandro, oye, ¿y qué pasa si yo quiero algo de la tabla del profesor? pues tengo dos opciones, ¿no? la primera es más obvia, la que veíamos la semana pasada, que es que combinar las tablas, ¿no? pero ¿qué ocurre? habrá casos en la vida real sobre todo, que nosotros combinemos dos tablas, ¿vale? imaginad que la segunda tabla tiene 50 atributos, es decir, 50 columnas es una tabla muy pesada ¿vale? y de esos 50 que yo quiero solo necesito un único campo ¿vale? entonces ahí también nos puede ayudar la subconsulta ¿por qué? por lo siguiente, ¿vale? nosotros, de hecho fijaros vamos a utilizar el ejemplo primero que utilizamos aquí, ¿vale? El de matrícula y alumno, ¿vale? Fijaros, nosotros aquí de la tabla de alumnos solo nos hace falta un campo, ¿vale? Que es el nombre. Pero imaginad que la tabla de alumno, en vez de tener seis atributos, tiene cien, ¿vale? Que son muchos. Es decir, si son cien atributos y voy a hacer un join, es algo bastante pesado, que va a conllevar un tiempo de procesamiento. Pero que nosotros realmente lo único que queremos es un único atributo de esos 100. Es decir, lo otro es 99, no me sirve. ¿Vale? Entonces, ¿qué puedo hacer yo? Puedo hacer lo siguiente, es decir, vale, a mí me hace falta la tabla de alumnos, pero no entera, me hace falta el nombre del alumno. ¿Vale? Es decir, yo lo que quiero es el nombre y lo quiero incluir aquí. Es decir, el número de alumnos me hace falta también. entonces yo digo vale, nombre de alumno y nombre de alumno los 99, 98 restantes no me interesan vale entonces que voy a hacer en vez de utilizar la tabla de alumno tal cual que voy a hacer utilizar la subconsulta y ahora que el funcionamiento es el mismo, me devuelve el mismo resultado, pero por detrás yo he optimizado el join, ¿vale? Es verdad que ahora mismo no lo vamos a notar, son pocos datos, tablas pequeñitas, pero esto, una tabla, como ya os he dicho, en realidad que tiene entre 50 y 100 atributos, que yo combine solo con 2 en vez de con 100, es algo que en términos de procesamiento se nota mucho. Por lo tanto, si nosotros no nos vale con filtrar, lo que podemos hacer es, primero, o sea, podemos hacer el join, pero primero limitando o filtrando nuestra tabla mediante subconsulta. ¿ok? esto de Alejandro es lo que tú decías, no, imagínate que a mí me hacen falta columnas, pues esto sería una posibilidad, ahora bien, imagina volviendo a este caso anterior yo podría por ejemplo, quiero el profesor ID y no sé, no sé que más había que más había en esta tabla, imagínate nacionalidad, ¿vale? imagínate Como decía Alejandro, oye, yo quiero que sean Javier y Jesús, pero me hace falta el nombre nacionalidad. Pues que pueda hacer un join, ¿vale? Así, inner join, y aquí, entre paréntesis, incluye mi subconsulta, ¿vale? Y esta subconsulta sería, ¿qué? Profesor. Y ahora especifico PR profesor ID que sea igual a ASIC profesor ID. Y ejecuto. Y como veis, efectivamente me aparecen Javier y Jesús. ¿Y por qué me aparecen? Primero, porque lo he filtrado aquí. Y lo segundo, ¿por qué? Porque he utilizado inner join. ¿Por qué? ¿Qué pasa? Si yo utilizo left join, ¿qué va a pasar? Me van a devolver los otros. pero van a estar nulos pero porque no es porque no haya datos en profesor sino que nosotros hemos filtrado antes profesor antes de combinar vale no en la subconsulta en el web te sirve para filtrar porque tú realmente aquí en este select no puedes utilizar en ningún campo de profesor simplemente sirve para filtrar eso lo hacemos cuando ya tenemos todos los atributos que necesitemos pero queremos filtrar por X campos utilizando otra tabla y si yo lo que necesito es optimizar una consulta porque en términos normales simplemente utilizamos inner join pero si hay demasiadas columnas en la segunda tabla primero la podemos filtrar o incluso la podemos filtrar a nivel de fila también y después combinarlo ¿vale? por ejemplo, exacto lo cual, precisamente lo que tú estás diciendo Alejandro, es lo que creo que fue María lo que lo preguntó, a ver lo voy a buscar cuando María preguntó ¿se podría almacenar un campo y después aplicarle el web? ¿vale? pues imagina si yo me vengo aquí voy a copiar la que tenía funciones de agregación antes y le voy a quitar el web fijaros, yo tengo este resultado entonces ahora que ocurre, yo puedo alimentar esta consulta como si fuese una tabla, de que manera select from y ahora entre paréntesis Entre paréntesis incluyo mi subconsulta. ¿Cuál es aquí la pega? Que aquí por narices le tengo que poner un alias, ¿vale? Para que identifique que es una tabla. Entonces, si yo aquí ejecuto, como veis, me devuelve el mismo resultado. Yo aquí, donde calculo, tenía que utilizar having, ¿verdad? pero ¿qué ocurre? aquí ya no me hace falta utilizar Javi, porque yo estoy tratando esta consulta como una tabla, y si yo aquí fuera en la otra consulta, sell from y esta es la tabla, le digo media mayor o igual que 6,5 si me funcionaría ¿vale? esto creo que es lo que tú también estabas refiriendo, ¿verdad Alejandro? esto es una posibilidad, es decir, si no queréis utilizar el HADDING hacéis primero todos los cálculos, después lo incluís en una subconsulta le hacéis un SELECT FROM y listo, también es una posibilidad ¿sí? claro, de todas maneras no os preocupéis esto simplemente lo estamos explicando todo esto obviamente lo vamos a a practicar ¿vale? ¿sí? ¿os habéis quedado pensativos? sí, efectivamente un poco lo de las subconsultas y de hecho las subconsultas no es lo más óptimo para escribir código, hay otra cosa que veremos más adelante que se llama CTE o como Table Expression que básicamente nosotros hacemos una serie de consultas bien separadas que forman parte de una única y progresivamente la vamos a ejecutar ¿vale? Catalina, entre el having y el where No te preocupes, ¿vale? El having es cuando nosotros calculamos algo, lo filtramos. El where filtramos por un atributo que ya está almacenado, ¿vale? Pero no te preocupes porque, como ahora os voy a explicar, os voy a subir una base de datos con ejercicios, ¿vale? Para que podáis practicar. De hecho, si os vais a documentación, ¿vale? Y os vais a scripts, vais a ver aquí que hay una carpeta nueva. que tiene tres archivos. Tiene dos archivos SQL y un Word. Los archivos SQL, uno es para MySQL y otro es para SQL Server. Me puede explicar el... Ah, vale, esto... Bueno, esto. Esto de aquí, el as, ¿qué es en esencia? ¿Para qué lo utilizamos, Paulina? El as es un alias. ¿vale? ¿a qué le estamos dando aquí al alias? a una tabla, solo que en vez de que sea el nombre de la tabla yo estoy aquí utilizando una consulta, que meto entre paréntesis y que para la primera consulta, que es este select from actúa como tabla ¿vale? pero el ask, sc, sc es como subconsulta, ¿vale? Simplemente le he dado ese nombre, igual que nosotros incluíamos aquí, ¿vale? Bien. Como decía, consultas SQL alumnos, ¿vale? Dos archivos de SQL y un Word. SQL Server, ¿qué hago? Pues abro mi SQL Server, ¿vale? Yo es que lo tengo aquí y me descargo el de Criptografía en base de datos, alumnos, SQL Server. Vengo aquí, lo ejecuto una vez y listo, ¿vale? Esto es una pequeña base de datos que se compone de estas tablas. Cuidado, porque aquí tenemos, antes hemos visto alumnos, ahora es alumnos, antes hemos visto profesor, ahora es profesor, antes hemos visto asignatura, ahora es asignatura. Perdonad por ser un poco repetitivo, pero quería seguir un poco el patrón. Entonces aquí tenemos cinco tablas, alumnos, profesores, asignaturas, expedientes y examen. ¿Vale? Y en MySQL lo mismo, ¿vale? En MySQL descargáis, lo abrís aquí, lo ejecutáis una vez y tenéis las mismas tablas. ¿vale? entonces ahora teniendo estas 5 tablas, ¿qué tenéis que hacer? esto de aquí, ¿vale? que de hecho es un prototipo de la actividad 2 aquí hay un total de 8 consultas que yo quiero que hagáis en base a lo que ya hemos visto, por ejemplo obtener el nombre de los alumnos que comiencen por la letra A y hayan nacido en Madrid o Barcelona o obtener el nombre de los profesores que impactan clase de alumnos que tengan aprobada más de un 5 en la asignatura de introducción de base de datos en junio de 2019 ¿vale? obviamente el nivel va subiendo ¿de acuerdo? intentad hacer alguna de ellas va a ser un poco recta, pero que igualmente la semana que viene en directo lo vamos a corregir y lo vamos a hacer entre todos ¿vale? porque ya he terminado de explicar la parte de explicar y ahora toca practicar ¿de acuerdo? pero igualmente intentad por vuestra cuenta hacer alguna de ellas ¿vale? voy a repetir que todo está en scripts, la sección de archivos, ¿vale? Consulta SQL Alumnos. ¿De acuerdo? Eso es lo que nos queda, Alejandro. Data por todos lados, efectivamente. ¿Todo bien? A ver, los que, si algunos os sentís un poco perdidos, no pasa nada, ¿vale? No pasa nada. Esto, la mejor manera de entenderlo es practicando, ¿vale? Y práctica vamos a dar mucha, ¿vale? Así que no os agobiéis, no pasa nada, cuesta, es normal, pero que con la práctica vamos a ir sacándolo todo, ¿vale? No os preocupéis. ¿Hablo muy rápido, William? Lo siento, os lo he dicho, decidme, decidme, decidme que baje el ritmo. Es que muchas veces tengo la manía de empezar a hablar muy rápido. No tengáis vergüenza, decídmelo, ¿vale? O sea, la pasión de William, de verdad, dímelo, oye, seguid un poco la velocidad, es una mala costumbre que tengo ¿vale? de ir demasiado rápido, pero que de verdad, insisto, no os preocupéis, ¿vale? o sea no os preocupéis, decídmelo, ¿vale? oye, seguid, vas demasiado rápido y yo bajo, y si vuelvo a ir rápido decídmelo otra vez, que no pasa nada, ¿eh? y mucho menos no os preocupéis, ¿vale? es que tengo esa manía de hablar demasiado rápido, ¿vale? pero que no tengáis vergüenza, me especificáis me lo decís y listo ¿vale? a principios siempre son las adventure box e insertamos tablas nuevas sí, es decir, para no crear una base de datos nueva para cada vez que carguéis tablas, lo que hacemos es utilizar ya adventure box, esta que está abogada y las tablas se crean ahí, ¿vale? para que sea más fácil también para vosotros ¿vale? hay que hacer pausas activas, no, tengo que respirar tengo que respirar muchas veces porque la verdad es que sí, que voy como una moto la mayoría de las veces ay, pues muchas gracias María, a ver es que yo os intento mostrar las cosas como de hecho en su día no me las mostraron a mí, a mí me soltaron con SQL tal cual fueron gente de ingeniería y ponían ejemplos que no tenían sentido y se centraban en lo técnico y lo técnico cuando te metes en programación rara vez funciona, tienes que poner ejemplos reales y practicar como si no hubiese un mañana ¿vale? Sí, es normal, William vamos, de hecho digo, personalmente no se lo he dicho alguna vez, yo no soy ingeniero ni mucho menos, o sea, yo estudié ADE por tema de mi familia, yo estuve limitado a lo que pude estudiar y yo después con el máster, fue cuando empecé a programar y demás, es decir, que yo vengo de ciencias sociales, por así decirlo por lo tanto, a ver, que esto se puede lo único que, pues hay que hay que practicar, ¿de acuerdo? así que nada, pues intentad, bueno, cargar la base de datos, ¿vale? nueva e intentad hacer algún que otra algún que otra ejercicio de las cuerdas que os he puesto pero que igualmente la semana que viene, ¿vale? Entre todos vamos a ir resolviendo los ejercicios, practicando qué hay que hacer y qué no hay que hacer ¿vale? Bien, pues nada, si no hay más dudas, si os parece lo dejamos por aquí, ¿vale? Os deseo a todos muy buena semana y nada, nos vemos la semana que viene el martes ya en horario normal ¿ok? Un saludo a todos, cuidaos mucho hasta luego Gracias.
