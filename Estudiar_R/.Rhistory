#summary(aguacates) #--> Creo que hay una manera de elegir solo columnas numericas y de omitir nans
#dim(aguacates)
#unique(aguacates) # creo que te buscan registros unicos, es decir iguales
#unique(aguacates$date) # aqui te toma solo las unicas de columnas
# names(aguacates) # he re recordado la función names(), me pregunto como modifificar el nombre de una columna, creo que con mutate, creo que es importante saber como cambiar nombres de columnas, quitar Nas y crear columnas calculadas o condicionales creo que se hace con mutate y libreria dplyr, a veces también te interesa hacer un subset()
colSums(is.na(aguacates))
# colSums(is.na(aguacates)) # quizas
colSums(is.numeric(aguacates))
# colSums(is.na(aguacates)) # quizas
# colSums(is.numeric(aguacates)) # he pensado otras maneras creativas de usar ColSums
sum(is.na(aguacates))
# colSums(is.na(aguacates)) # quizas
# colSums(is.numeric(aguacates)) # he pensado otras maneras creativas de usar ColSums
sum(is.numeric(aguacates))
# colSums(is.na(aguacates)) # quizas
# colSums(is.numeric(aguacates)) # he pensado otras maneras creativas de usar ColSums
sum(is.numeric(aguacates))
# colSums(is.na(aguacates)) # quizas
# colSums(is.numeric(aguacates)) # he pensado otras maneras creativas de usar ColSums
sum(is.num(aguacates))
table(aguacates)
table(aguacates$type)
table(aguacates$type) # pensando sobre esto, crea como frecuencias de los valores de una dimensión
pro.table(table(aguacates$type))
table(aguacates$type) # pensando sobre esto, crea como frecuencias de los valores de una dimensión
pro.table(table(aguacates$type))
table(aguacates$type) # pensando sobre esto, crea como frecuencias de los valores de una dimensión
prop.table(table(aguacates$type))
table(aguacates$type) # pensando sobre esto, crea como frecuencias de los valores de una dimensión
prop.table(table(aguacates$type)) * 100
subset(aguacates, type="organic")
subset(aguacates, type="organic" or date > "2025-01-11")
subset(aguacates, type="organic"  |  date > "2025-01-11")
subset(aguacates, type="organic"  |  date > "2025-01-11") # esto no funciona y creo que debería
subset(aguacates, aguacates$type="organic"  |  aguacates$date > "2025-01-11") # esto no funciona y creo que debería
subset(aguacates, type="organic"  |  date > "2025-01-11") # esto no funciona y creo que debería
subset(aguacates, aguacates$type=="organic"  |  aguacates$date > "2025-01-11") # esto no funciona y creo que debería
aguacates$type <- as.factor(aguacates$type)
aguacates$total_volume <- as.numeric(aguacates$total_volume)
# calculamos desviacion standard
std(aguacates_org$average_price)
# calculamos desviacion standard
std(aguacates$average_price)
# calculamos desviacion standard
std(aguacates$average_price)
# calculamos desviacion standard
sd(aguacates$average_price)
# calculamos desviacion standard
sd(aguacates_org$average_price) #
# calculamos desviacion standard
sd(aguacates_org$average_price) #
# calculamos desviacion standard
sd(aguacates$average_price) #
# calculamos desviacion standard
sd(aguacates$average_price) #
corr(aguacates$average_price, aguacates$total_volume)
# calculamos desviacion standard
sd(aguacates$average_price) #
cor(aguacates$average_price, aguacates$total_volume)
# calculamos desviacion standard
#sd(aguacates$average_price) #
cor(aguacates$average_price, aguacates$total_volume)
knitr::opts_chunk$set(echo = TRUE)
setwd("/Users/alejandrocamposlamas/Proyectos/ACTIVIDADES_UNIR/Estudiar_R")
vector <- c(1,2, "tres")
class(vector)
edades <- c(25, 32, 41, 28, 35 )
nombres <-  c("Alejandro", "Jorge", "Ramon", "Judy", "Pablo")
personas <- data.frame(edades, nombres)
mean(personas$edades)
genero = c("H", "H","M", "M", "H")
personas <- data.frame(edades, nombres, genero)
personas$genero <-as.factor(personas$genero)
summary(personas)
table(personas$genero) # conteo de frecuencias
#cargamos
aguacates <- read.csv("Actividades/Actividad_1/Actividad 1 – Grupo3 - Análisis de datos de aguacate.csv")
#vemos estructura
str(aguacates) # aquí deberiamos  filtrar seguramente la geografía
# usamos summary()
summary(aguacates) # deberiamos convertir a factor type
# cuantas filas y columnas tiene?
nrow(aguacates)
ncol(aguacates)
dim(aguacates)
dim(aguacates)[1]
dim(aguacates)[2]
# ¿no hay alguna manera de hacer una especia de size() como en python?
# Type debería ser un factor porque es una cateogría y ahora está en varchar
aguacates$type <- as.factor(aguacates$type)
# creo que también tendría que mirar si hay algun null, creo que sea hacer con colSums(is.na) o algo asi, en el caso de hacer null filtrar quitando los nulls
# parece que filtrar es importante tanto nulls como registros de geografías que no son importantes, estos son temas que pueden surgir en el examen. Veo que subset() es algo que tiene preparado el profesor y tiene relación con esto
# summary() es un proceso iterativo, uno hace el summary y se da cuenta que quizás deba filtrar columnas o elegir solo las numericas, etc.
#Parece que al igual de importante que saber hacer un summary() es importante saber interpretar, posiblemente no interpretar todo de todas las columnas, pero si de aquellas que sean objeto de estudio, por ejemplo averge_price o total_colume.
# Creo que la profesora menciono que todo aquello que fuera 0, 1,
colSums(is.na(aguacates))
sum(is.na(aguacates))
prop.table(table(aguacates$type)) * 100
aguacates_org <- subset(aguacates, aguacates$type == "organic")
nrow(aguacates_org)
# miro names(aguacates)
# miro unique(aguacates$geography)
aguacates_org <- subset(aguacates, aguacates$type == "organic" & aguacates$geography == "Albany")
nrow(aguacates_org)
# Creo que las condiciones pueden ser OR o AND, en este caso he usado AND pero podria ser OR que es asi |
# precio medio aguacates
mean(aguacates_org$average_price)
# creo que filtrar es muy importante, además de para filtrar a veces hay que investigar las columnas, las filas, si hay nans, o si algun dato no debería estar, por ejemplo, hay regiones en geography que no tienen sentido, me di cuenta hacer un   unique(aguacates$geography), o aveces querrremos omitir columnas en el subset, creo importante hacer esto.
#str(aguacates)
#summary(aguacates) #--> Creo que hay una manera de elegir solo columnas numericas y de omitir nans
#dim(aguacates)
#unique(aguacates) # creo que te buscan registros unicos, es decir iguales
#unique(aguacates$date) # aqui te toma solo las unicas de columnas
# names(aguacates) # he re recordado la función names(), me pregunto como modifificar el nombre de una columna, creo que con mutate, creo que es importante saber como cambiar nombres de columnas, quitar Nas y crear columnas calculadas o condicionales creo que se hace con mutate y libreria dplyr, a veces también te interesa hacer un subset()
table(aguacates$type) # pensando sobre esto, crea como frecuencias de los valores de una dimensión
prop.table(table(aguacates$type)) * 100 # la conclusión seria que se han vendido a partes iguales los orgánicos y convencionales...
subset(aguacates, type="organic"  |  date > "2025-01-11") # esto no funciona y creo que debería
subset(aguacates, aguacates$type=="organic"  |  aguacates$date > "2025-01-11") # esto no funciona y creo que debería
# creo que los subsets se pueden hacer con corchetes o con la libreria dplyr
# importante saber filtrar por culmunas y por filos, por ejemplo quitar regiones que no deberían estar
subset(aguacates, type="organic"  |  date > "2025-01-11") # esto no funciona y creo que debería
subset(aguacates_org, aguacates$type=="organic"  |  aguacates$date > "2025-01-11") # esto no funciona y creo que debería
# creo que los subsets se pueden hacer con corchetes o con la libreria dplyr
# importante saber filtrar por culmunas y por filos, por ejemplo quitar regiones que no deberían estar
# calculamos desviacion standard
#sd(aguacates$average_price) #
cor(aguacates_org$average_price, aguacates_org$total_volume)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
setwd("/Users/alejandrocamposlamas/Proyectos/ACTIVIDADES_UNIR/Estudiar_R")
# Ejemplo de coerción: números + texto = todo texto
vector_mixto <- c(1, 2, "tres")
class(vector_mixto)  # "character"
edades <- c(25, 32, 41, 28, 35)
nombres <- c("Alejandro", "Jorge", "Ramon", "Judy", "Pablo")
genero <- c("H", "H", "M", "M", "H")
personas <- data.frame(edades, nombres, genero)
personas$genero <- as.factor(personas$genero)
# Exploración
summary(personas)
table(personas$genero)
mean(personas$edades)
aguacates <- read.csv("Actividades/Actividad_1/Actividad 1 – Grupo3 - Análisis de datos de aguacate.csv")
# Estructura
str(aguacates)
# Dimensiones
dim(aguacates)  # filas, columnas
# Nombres de columnas
names(aguacates)
# Type es categórica, debe ser factor
aguacates$type <- as.factor(aguacates$type)
sum(is.na(aguacates))        # Total NAs
colSums(is.na(aguacates))    # NAs por columna
summary(aguacates)
# Para ver solo columnas numéricas:
# aguacates[, sapply(aguacates, is.numeric)]
# Absoluta
table(aguacates$type)
# Relativa (porcentaje)
prop.table(table(aguacates$type)) * 100
# Filtrar orgánicos (NO repetir aguacates$ dentro de subset)
aguacates_org <- subset(aguacates, type == "organic")
nrow(aguacates_org)
# Filtrar orgánicos de Albany (AND)
aguacates_org_albany <- subset(aguacates, type == "organic" & geography == "Albany")
nrow(aguacates_org_albany)
# Filtrar con OR
# subset(aguacates, type == "organic" | geography == "Boston")
# Seleccionar columnas específicas
# subset(aguacates, type == "organic", select = c(geography, average_price))
# Usando el subset de Albany
mean(aguacates_org_albany$average_price)
sd(aguacates_org_albany$average_price)
cor(aguacates_org_albany$average_price, aguacates_org_albany$total_volume)
class(x)
x <-  3.14
class(x)
x <- as.integer(x)
x
class(x)
class (x)
x = 0
x <-  3.14
class(x)
x <- as.integer(x)
x
class(x)
x = 0
class (x)
x <-  as.logical(x)
x <-  3.14
class(x)
x <- as.integer(x)
x
class(x)
x = 0
class (x)
x <-  as.logical(x)
x
cat("Hola Mundo \n")
cat("Hola Mundo \n")
nombre <-  readline("ingresa tu nombre: ")
cat("Hola Mundo \n")
nombre <-  readline("ingresa tu nombre: ")
cat("Hola", nombre)
cat("Hola Mundo \n")
nombre <-  readline("ingresa tu nombre: ")
cat("Hola", nombre)
x <-  -5
if {x>0} {
cat("Hola Mundo \n")
nombre <-  readline("ingresa tu nombre: ")
cat("Hola", nombre)
x <-  -5
if {x>0} {
if (x>0) {
cat("x es positivio \n")
} else if (x < 0) {
cat("x es negativo \n")
} else {
cat("x es cero \n")
}
library(readxl)
#datos_excel <- read_excel("archivo.xlsx")
coaster_db <- read_csv("./datasets/coaster_db.csv")
library(readxl)
#datos_excel <- read_excel("archivo.xlsx")
coaster_db <- read_csv("./datasets/coaster_db.csv")
library(readxl)
#datos_excel <- read_excel("archivo.xlsx")
coaster_db <- read.csv("./datasets/coaster_db.csv")
view(datos)
View(datos)
View(coaster_db)
dim(datos)
dim(coaster_db)
head(coaster_db)
str(coaster_db)
names(coaster_db)
unique(coaster_db$Status)
summaru(coaster_db[, sapply(coaster_db, is.numeric))
summaru(coaster_db[, sapply(coaster_db, is.numeric)
summary(coaster_db[, sapply(coaster_db, is.numeric)
summary(coaster_db[, sapply(coaster_db, is.numeric))
summary(coaster_db[, sapply(coaster_db, is.numeric)])
summary(na.omit, coaster_db[, sapply(coaster_db, is.numeric)]))
summary(na.omit, coaster_db[, sapply(coaster_db, is.numeric)])
summary(na.omit(coaster_db[, sapply(coaster_db, is.numeric)]))
var(coaster_db$latitude, na.rm=TRUE)
coaster_db$latitude
mean(coaster_db$latitude, na.rm=TRUE)
mean(coaster_db$latitude)
, na.rm=TRUE)
mean(coaster_db$latitude, na.rm=TRUE)
mean(coaster_db$latitude, na.rm=TRUE) # importante na.rm=TRUE
library(dplyr)
```{r 43 seleccion columnas}
#library(dplyr)
coaster_db_sin_height <- coaster_db[,-coaster_db$Height]
coaster_db_sin_height <- coaster_db[,-"Height"]
names(coaster_db)
coaster_db_sin_height <- coaster_db[,filtro_columnas]
#library(dplyr)
filtro_columnas <- names(coaster_db) != "Height"
coaster_db_sin_height <- coaster_db[,filtro_columnas]
# sin usar library(dplyr)
# OPCION A
filtro_columnas <- names(coaster_db) != "Height"
coaster_db_sin_height <- coaster_db[,filtro_columnas]
# OPCIÓN B
coaster_db_sin_height <-  subset(coaster_db, select= -Height)
# Usando Dplyr
library(dplyr)
filtro_columnas <- names(coaster_db) != ("Height", "Speed")
# sin usar library(dplyr)
## OPCION A
filtro_columnas <- names(coaster_db) != "Height"
filtro_columnas <- names(coaster_db) != ("Height", "Speed")
filtro_columnas <- names(coaster_db) != ["Height", "Speed"]
# sin usar library(dplyr)
## OPCION A
filtro_columnas <- names(coaster_db) != "Height"
filtro_columnas <- names(coaster_db) != ["Height", "Speed"]
filtro_columnas <- names(coaster_db) != c("Height", "Speed")
# sin usar library(dplyr)
## OPCION A
filtro_columnas <- names(coaster_db) != "Height"
filtro_columnas <- names(coaster_db) != c("Height", "Speed")
coaster_db_sin_height <- coaster_db[,filtro_columnas]
## OPCIÓN B
coaster_db_sin_height <-  subset(coaster_db, select= -Height)
# Usando Dplyr
library(dplyr)
coaster_db_sin_height <- coaster_db %>% select(-Height)
# sin usar library(dplyr)
## OPCION A
filtro_columnas <- names(coaster_db) != "Height"
filtro_columnas <- names(coaster_db) != c("Height", "Speed")
coaster_db_sin_height <- coaster_db[,filtro_columnas]
## OPCIÓN B
coaster_db_sin_height <-  subset(coaster_db, select= -Height, -Speed)
# Usando Dplyr
library(dplyr)
coaster_db_sin_height <- coaster_db[,filtro_columnas]
library(dplyr)
coaster_db_sin_height <- coaster_db %>% select(-Height)
coaster_db_sin_height <- coaster_db |>
select(-Height, -Speed)
coaster_db_sin_height <- coaster_db |>
select(-c(Height, Speed)
# sin usar library(dplyr)
## OPCION A
filtro_columnas <- names(coaster_db) != "Height"
# sin usar library(dplyr)
## OPCION A
filtro_columnas <- names(coaster_db) != "Height"
coaster_db_sin_height <- coaster_db[,filtro_columnas]
vars_to_drop <-  c("Height", "Speed")
filtro_columnas <- !names(coaster_db) %in% vars_to_drop
coaster_db_sin_cols <-  coaster_db[, filtro_columnas]
## OPCIÓN B
coaster_db_sin_height <-  subset(coaster_db, select= -Height)
coaster_db_sin_height <-  subset(coaster_db, select= -c(Height, Speed))
# Usando Dplyr
library(dplyr)
coaster_db_sin_height <- coaster_db %>% select(-Height)
coaster_db_sin_height <- coaster_db |>
select(-Height, -Speed)
coaster_db_sin_height <- coaster_db |>
select(-c(Height, Speed))
# sin usar library(dplyr)
## OPCION A
filtro_columnas <- names(coaster_db) != "Height"
coaster_db_sin_height <- coaster_db[,filtro_columnas]
vars_to_drop <-  c("Height", "Speed")
filtro_columnas <- !names(coaster_db) %in% vars_to_drop
coaster_db_sin_cols <-  coaster_db[, filtro_columnas]
## OPCIÓN B
coaster_db_sin_height <-  subset(coaster_db, select= -Height)
coaster_db_sin_height <-  subset(coaster_db, select= -c(Height, Speed))
solo_height <- subset(coaster_db, select= Height)
# Usando Dplyr
library(dplyr)
coaster_db_sin_height <- coaster_db %>% select(-Height)
coaster_db_sin_height <- coaster_db |>
select(-Height, -Speed)
coaster_db_sin_height <- coaster_db |>
select(-c(Height, Speed))
head(solo_height)
# sin usar library(dplyr)
## OPCION A
filtro_columnas <- names(coaster_db) != "Height"
coaster_db_sin_height <- coaster_db[,filtro_columnas]
vars_to_drop <-  c("Height", "Speed")
filtro_columnas <- !names(coaster_db) %in% vars_to_drop
coaster_db_sin_cols <-  coaster_db[, filtro_columnas]
## OPCIÓN B
coaster_db_sin_height <-  subset(coaster_db, select= -Height)
coaster_db_sin_height <-  subset(coaster_db, select= -c(Height, Speed))
solo_height <- subset(coaster_db, select= Height)
# Usando Dplyr
library(dplyr)
coaster_db_sin_height <- coaster_db %>% select(-Height)
coaster_db_sin_height <- coaster_db |>
select(-Height, -Speed)
coaster_db_sin_height <- coaster_db |>
select(-c(Height, Speed))
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
setwd("/Users/alejandrocamposlamas/Proyectos/ACTIVIDADES_UNIR/Estudiar_R")
nombre <-  "Alejandro"
apellido <-  "Campos"
x <-  3.14
class(x)
x <- as.integer(x)
x
class(x)
x = 0
class (x)
x <-  as.logical(x)
cat("Hola Mundo \n")
nombre <-  readline("ingresa tu nombre: ")
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
setwd("/Users/alejandrocamposlamas/Proyectos/ACTIVIDADES_UNIR/Estudiar_R")
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
setwd("/Users/alejandrocamposlamas/Proyectos/ACTIVIDADES_UNIR/Estudiar_R")
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
setwd("ACTIVIDADES_UNIR/Estudiar_R")
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
#setwd("ACTIVIDADES_UNIR/Estudiar_R")
nombre <-  "Alejandro"
apellido <-  "Campos"
x <-  3.14
class(x)
x <- as.integer(x)
x
class(x)
x = 0
class (x)
x <-  as.logical(x)
cat("Hola Mundo \n")
nombre <-  readline("ingresa tu nombre: ")
cat("Hola", nombre)
x <-  -5
if (x>0) {
cat("x es positivio \n")
} else if (x < 0) {
cat("x es negativo \n")
} else {
cat("x es cero \n")
}
library(readxl)
#datos_excel <- read_excel("archivo.xlsx")
coaster_db <- read.csv("./datasets/coaster_db.csv")
View(coaster_db)
View(coaster_db)
dim(coaster_db)
head(coaster_db)
str(coaster_db)
names(coaster_db)
unique(coaster_db$Status)
summary(coaster_db)
summary(coaster_db[, sapply(coaster_db, is.numeric)]) # solo las numéricas
summary(na.omit(coaster_db[, sapply(coaster_db, is.numeric)])) # solo numericas y y sin nans
library(dplyr)
#datos %>%
#  select(where(is.numeric)) %>% # Selecciona numeric e integer
#  na.omit() %>%                # Elimina filas que contengan NA
#  summary()
var(coaster_db$latitude, na.rm=TRUE)
mean(coaster_db$latitude, na.rm=TRUE) # importante na.rm=TRUE
# sin usar library(dplyr)
## OPCION A
filtro_columnas <- names(coaster_db) != "Height"
coaster_db_sin_height <- coaster_db[,filtro_columnas]
vars_to_drop <-  c("Height", "Speed")
filtro_columnas <- !names(coaster_db) %in% vars_to_drop
coaster_db_sin_cols <-  coaster_db[, filtro_columnas]
## OPCIÓN B
coaster_db_sin_height <-  subset(coaster_db, select= -Height)
coaster_db_sin_height <-  subset(coaster_db, select= -c(Height, Speed))
solo_height <- subset(coaster_db, select= Height)
# Usando Dplyr
library(dplyr)
coaster_db_sin_height <- coaster_db %>% select(-Height)
coaster_db_sin_height <- coaster_db |>
select(-Height, -Speed)
coaster_db_sin_height <- coaster_db |>
select(-c(Height, Speed))
coaster_db[coaster_db$Status %in% c("Closed", "Removed") & coaster_db$year_introduced > 1980  ]
coaster_db$year_introduced
coaster_db[coaster_db$Status %in% c("Closed", "Removed") & coaster_db$year_introduced > 1985]
# R de base
coaster_db[coaster_db$Status %in% c("Closed", "Removed") & coaster_db$year_introduced > 1985, ]
coaster_filtrado <- coaster_db |> filter(Status %in% c("Closed", "Removed"), year_introduced > 1985)
# R de base
coaster_filtrado <- coaster_db[coaster_db$Status %in% c("Closed", "Removed") & coaster_db$year_introduced > 1985, ]
coaster_filtrado <- coaster_db |> filter(Status %in% c("Closed", "Removed"), year_introduced > 1985)
coaster_filtrado_c <- coaster_db[coaster_db$Status %in% c("Closed", "Removed") & coaster_db$year_introduced > 1985, Status]
coaster_filtrado
coaster_filtrado_c <- coaster_db[coaster_db$Status %in% c("Closed", "Removed") & coaster_db$year_introduced > 1985, coaster_name]
coaster_filtrado_c <- coaster_db[coaster_db$Status %in% c("Closed", "Removed") & coaster_db$year_introduced > 1985, "coaster_name"]
# R de base
coaster_filtrado <- coaster_db[coaster_db$Status %in% c("Closed", "Removed") & coaster_db$year_introduced > 1985, ]
coaster_filtrado_c <- coaster_db[coaster_db$Status %in% c("Closed", "Removed") & coaster_db$year_introduced > 1985, "coaster_name"]
# Opción Robusta A (Explicita):
condicion <- coaster_db$year_introduced > 1985 & !is.na(coaster_db$year_introduced)
coaster_filtrado <- coaster_db[condicion, ]
# Opción Robusta B (Función which - truco de senior):
# which() devuelve solo los índices que son TRUE, ignorando los NA
coaster_filtrado <- coaster_db[which(coaster_db$year_introduced > 1985), ]
# dplyr
coaster_filtrado <- coaster_db |> filter(Status %in% c("Closed", "Removed"), year_introduced > 1985)
coaster_filtrado
coaster_filtrado
# R de base
coaster_filtrado <- coaster_db[coaster_db$Status %in% c("Closed", "Removed") & coaster_db$year_introduced > 1985, ]
coaster_filtrado_c <- coaster_db[coaster_db$Status %in% c("Closed", "Removed") & coaster_db$year_introduced > 1985, "coaster_name"]
# Opción Robusta A (Explicita):
condicion <- coaster_db$year_introduced > 1985 & !is.na(coaster_db$year_introduced)
coaster_filtrado <- coaster_db[condicion, ]
# Opción Robusta B (Función which - truco de senior):
# which() devuelve solo los índices que son TRUE, ignorando los NA
coaster_filtrado <- coaster_db[which(coaster_db$year_introduced > 1985), ]
# dplyr
coaster_filtrado <- coaster_db |> filter(Status %in% c("Closed", "Removed"), year_introduced > 1985)
coaster_filtrado
# R de base
coaster_filtrado <- coaster_db[coaster_db$Status %in% c("Closed", "Removed") & coaster_db$year_introduced > 1985, ]
coaster_filtrado_c <- coaster_db[coaster_db$Status %in% c("Closed", "Removed") & coaster_db$year_introduced > 1985, "coaster_name"]
# Opción Robusta A (Explicita):
condicion <- coaster_db$year_introduced > 1985 & !is.na(coaster_db$year_introduced)
coaster_filtrado <- coaster_db[condicion, ]
# Opción Robusta B (Función which - truco de senior):
# which() devuelve solo los índices que son TRUE, ignorando los NA
coaster_filtrado <- coaster_db[which(coaster_db$year_introduced > 1985), ]
# dplyr
coaster_filtrado <- coaster_db |> filter(Status %in% c("Closed", "Removed"), year_introduced > 1985)
coaster_filtrado_c
# R de base
coaster_filtrado <- coaster_db[coaster_db$Status %in% c("Closed", "Removed") & coaster_db$year_introduced > 1985, ]
coaster_filtrado_c <- coaster_db[coaster_db$Status %in% c("Closed", "Removed") & coaster_db$year_introduced > 1985, "coaster_name"]
# Opción Robusta A (Explicita):
condicion <- coaster_db$year_introduced > 1985 & !is.na(coaster_db$year_introduced)
coaster_filtrado <- coaster_db[condicion, ]
# Opción Robusta B (Función which - truco de senior):
# which() devuelve solo los índices que son TRUE, ignorando los NA
coaster_filtrado <- coaster_db[which(coaster_db$year_introduced > 1985), ]
# dplyr
coaster_filtrado <- coaster_db |> filter(Status %in% c("Closed", "Removed"), year_introduced > 1985)
# R base
coaster_filtrado$calculo <- coaster_filtrado$Length - coaster_filtrado$Speed
# R base
coaster_filtrado$calculo <- coaster_filtrado$Length - coaster_filtrado$Height
